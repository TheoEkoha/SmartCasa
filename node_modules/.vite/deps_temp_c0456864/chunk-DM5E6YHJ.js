import {
  hashMessage
} from "./chunk-OJSKMF74.js";
import {
  sign,
  signTransaction
} from "./chunk-DRLWARYC.js";
import {
  createWalletEmitter
} from "./chunk-6YBCAPAW.js";
import {
  parseTypedData
} from "./chunk-RIKVLZUS.js";
import {
  eth_sendRawTransaction
} from "./chunk-CMXLKATA.js";
import {
  hashTypedData,
  publicKeyToAddress
} from "./chunk-6JYFO65Y.js";
import {
  getRpcClient
} from "./chunk-3LA3WHQL.js";
import {
  secp256k1
} from "./chunk-7YU2D6DQ.js";
import {
  hexToBigInt,
  toHex
} from "./chunk-BNK74YTA.js";
import {
  getCachedChain,
  getCachedChainIfExists
} from "./chunk-RD7ZD5L5.js";

// node_modules/thirdweb/dist/esm/utils/signatures/signature-to-hex.js
function signatureToHex(signature) {
  const { r, s, v, yParity } = signature;
  const yParity_ = (() => {
    if (yParity === 0 || yParity === 1)
      return yParity;
    if (v && (v === 27n || v === 28n || v >= 35n))
      return v % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })();
  return `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${yParity_ === 0 ? "1b" : "1c"}`;
}

// node_modules/thirdweb/dist/esm/utils/signatures/sign-message.js
function signMessage(options) {
  if ("privateKey" in options) {
    const { message, privateKey } = options;
    const signature = sign({ hash: hashMessage(message), privateKey });
    return signatureToHex(signature);
  } else if ("account" in options) {
    const { message, account } = options;
    return account.signMessage({ message });
  } else {
    throw new Error("Either privateKey or account is required");
  }
}

// node_modules/thirdweb/dist/esm/utils/signatures/sign-typed-data.js
function signTypedData(options) {
  const { privateKey, ...typedData } = options;
  const parsedTypeData = parseTypedData(typedData);
  const signature = sign({
    hash: hashTypedData(parsedTypeData),
    // TODO: Implement native hashTypedData
    privateKey
  });
  return signatureToHex(signature);
}

// node_modules/thirdweb/dist/esm/wallets/private-key.js
function privateKeyToAccount(options) {
  const { client } = options;
  const privateKey = `0x${options.privateKey.replace(/^0x/, "")}`;
  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false));
  const address = publicKeyToAddress(publicKey);
  const account = {
    address,
    sendTransaction: async (tx) => {
      const rpcRequest = getRpcClient({
        client,
        chain: getCachedChain(tx.chainId)
      });
      const signedTx = signTransaction({
        transaction: tx,
        privateKey
      });
      const transactionHash = await eth_sendRawTransaction(rpcRequest, signedTx);
      return {
        transactionHash
      };
    },
    signMessage: async ({ message }) => {
      return signMessage({
        message,
        privateKey
      });
    },
    signTypedData: async (_typedData) => {
      return signTypedData({
        ..._typedData,
        privateKey
      });
    },
    signTransaction: async (tx) => {
      return signTransaction({
        transaction: tx,
        privateKey
      });
    }
  };
  return account;
}

// node_modules/thirdweb/dist/esm/wallets/utils/generateAccount.js
async function generateAccount(options) {
  const privateKey = toHex(secp256k1.utils.randomPrivateKey());
  return privateKeyToAccount({ privateKey, client: options.client });
}

// node_modules/thirdweb/dist/esm/wallets/getAllWalletsList.js
async function getAllWalletsList() {
  return (await import("./wallet-infos-5IIHU42H.js")).default;
}

// node_modules/thirdweb/dist/esm/adapters/wallet-adapter.js
function createWalletAdapter(options) {
  const emitter = createWalletEmitter();
  let _chain = options.chain;
  return {
    id: "adapter",
    subscribe: emitter.subscribe,
    connect: async () => {
      emitter.emit("onConnect", options);
      return options.adaptedAccount;
    },
    autoConnect: async () => {
      emitter.emit("onConnect", options);
      return options.adaptedAccount;
    },
    disconnect: async () => {
      await options.onDisconnect();
      emitter.emit("disconnect", void 0);
    },
    getAccount() {
      return options.adaptedAccount;
    },
    getChain() {
      const cachedChain = getCachedChainIfExists(_chain.id);
      _chain = cachedChain || _chain;
      return _chain;
    },
    getConfig() {
      return options;
    },
    switchChain: async (chain) => {
      await options.switchChain(chain);
      _chain = chain;
      emitter.emit("chainChanged", chain);
    }
  };
}

export {
  privateKeyToAccount,
  generateAccount,
  getAllWalletsList,
  createWalletAdapter
};
//# sourceMappingURL=chunk-DM5E6YHJ.js.map
