import {
  serializeTransaction
} from "./chunk-6JYFO65Y.js";
import {
  keccak256
} from "./chunk-CY3CMUVN.js";
import {
  secp256k1
} from "./chunk-7YU2D6DQ.js";
import {
  toHex
} from "./chunk-BNK74YTA.js";

// node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js
function serializeTransaction2(options) {
  const { transaction } = options;
  const signature = (() => {
    if (options.signature)
      return options.signature;
    if (transaction.v === void 0 && transaction.yParity === void 0) {
      return void 0;
    }
    if (transaction.r === void 0 || transaction.s === void 0) {
      throw new Error("Invalid signature provided with transaction");
    }
    return {
      v: transaction.v,
      r: transaction.r,
      s: transaction.s,
      yParity: transaction.yParity
    };
  })();
  return serializeTransaction(transaction, signature);
}

// node_modules/thirdweb/dist/esm/utils/signatures/sign.js
function sign({ hash, privateKey }) {
  const { r, s, recovery } = secp256k1.sign(hash.slice(2), privateKey.slice(2));
  return {
    r: toHex(r, { size: 32 }),
    s: toHex(s, { size: 32 }),
    v: recovery ? 28n : 27n,
    yParity: recovery
  };
}

// node_modules/thirdweb/dist/esm/transaction/actions/sign-transaction.js
function signTransaction({ transaction, privateKey }) {
  if (transaction.type === "eip4844") {
    transaction = { ...transaction, sidecars: false };
  }
  const serializedTransaction = serializeTransaction2({ transaction });
  const signature = sign({
    hash: keccak256(serializedTransaction),
    privateKey
  });
  return serializeTransaction2({
    transaction: { ...transaction, ...signature }
  });
}

export {
  sign,
  serializeTransaction2 as serializeTransaction,
  signTransaction
};
//# sourceMappingURL=chunk-DRLWARYC.js.map
