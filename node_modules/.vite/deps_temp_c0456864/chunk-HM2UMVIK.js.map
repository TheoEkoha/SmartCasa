{
  "version": 3,
  "sources": ["../../thirdweb/src/wallets/in-app/core/authentication/linkAccount.ts", "../../thirdweb/src/wallets/in-app/core/wallet/in-app-core.ts"],
  "sourcesContent": ["import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport type { Profile } from \"./types.js\";\n\n/**\n * @description\n * Links a new account to the current one using an auth token.\n * For the public-facing API, use `wallet.linkProfile` instead.\n *\n * @internal\n */\nexport async function linkAccount({\n  client,\n  tokenToLink,\n}: {\n  client: ThirdwebClient;\n  tokenToLink: string;\n}): Promise<Profile[]> {\n  const IN_APP_URL = getThirdwebBaseUrl(\"inAppWallet\");\n  const currentAccountToken = localStorage.getItem(\n    `walletToken-${client.clientId}`,\n  );\n\n  if (!currentAccountToken) {\n    throw new Error(\"Failed to link account, no user logged in\");\n  }\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer iaw-auth-token:${currentAccountToken}`,\n    \"x-thirdweb-client-id\": client.clientId,\n  };\n\n  const linkedDetailsResp = await fetch(\n    `${IN_APP_URL}/api/2024-05-05/account/connect`,\n    {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        accountAuthTokenToConnect: tokenToLink,\n      }),\n    },\n  );\n\n  if (!linkedDetailsResp.ok) {\n    const body = await linkedDetailsResp.json();\n    throw new Error(body.message || \"Failed to link account.\");\n  }\n\n  const { linkedAccounts } = await linkedDetailsResp.json();\n\n  return (linkedAccounts ?? []) satisfies Profile[];\n}\n\n/**\n * @description\n * Gets the linked accounts for the current user.\n * For the public-facing API, use `wallet.getProfiles` instead.\n *\n * @internal\n */\nexport async function getLinkedProfilesInternal({\n  client,\n}: { client: ThirdwebClient }): Promise<Profile[]> {\n  const IN_APP_URL = getThirdwebBaseUrl(\"inAppWallet\");\n  const currentAccountToken = localStorage.getItem(\n    `walletToken-${client.clientId}`,\n  );\n\n  if (!currentAccountToken) {\n    throw new Error(\"Failed to get linked accounts, no user logged in\");\n  }\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer iaw-auth-token:${currentAccountToken}`,\n    \"x-thirdweb-client-id\": client.clientId,\n  };\n\n  const linkedAccountsResp = await fetch(\n    `${IN_APP_URL}/api/2024-05-05/accounts`,\n    {\n      method: \"GET\",\n      headers,\n    },\n  );\n\n  if (!linkedAccountsResp.ok) {\n    const body = await linkedAccountsResp.json();\n    throw new Error(body.message || \"Failed to get linked accounts.\");\n  }\n\n  const { linkedAccounts } = await linkedAccountsResp.json();\n\n  return (linkedAccounts ?? []) satisfies Profile[];\n}\n", "import { trackConnect } from \"../../../../analytics/track.js\";\nimport type { Chain } from \"../../../../chains/types.js\";\nimport { getCachedChainIfExists } from \"../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport type { Account, Wallet } from \"../../../interfaces/wallet.js\";\nimport { createWalletEmitter } from \"../../../wallet-emitter.js\";\nimport type { CreateWalletArgs } from \"../../../wallet-types.js\";\nimport type { Ecosystem } from \"../../web/types.js\";\nimport {\n  getLinkedProfilesInternal,\n  linkAccount as linkProfileWithToken,\n} from \"../authentication/linkAccount.js\";\nimport type {\n  MultiStepAuthArgsType,\n  Profile,\n  SingleStepAuthArgsType,\n} from \"../authentication/types.js\";\nimport type { InAppConnector } from \"../interfaces/connector.js\";\n\nconst connectorCache = new WeakMap<\n  { client: ThirdwebClient; ecosystem?: Ecosystem },\n  InAppConnector\n>();\n\n/**\n * @internal\n */\nexport async function getOrCreateInAppWalletConnector(\n  client: ThirdwebClient,\n  connectorFactory: (client: ThirdwebClient) => Promise<InAppConnector>,\n  ecosystem?: Ecosystem,\n) {\n  const key = { client, ecosystem };\n  if (connectorCache.has(key)) {\n    return connectorCache.get(key) as InAppConnector;\n  }\n  const connector = await connectorFactory(client);\n  connectorCache.set(key, connector);\n  return connector;\n}\n\n/**\n * @internal\n */\nexport function createInAppWallet(args: {\n  createOptions?: CreateWalletArgs<\"inApp\">[1];\n  connectorFactory: (client: ThirdwebClient) => Promise<InAppConnector>;\n}): Wallet<\"inApp\"> {\n  const { createOptions, connectorFactory } = args;\n  const emitter = createWalletEmitter<\"inApp\">();\n  let account: Account | undefined = undefined;\n  let chain: Chain | undefined = undefined;\n  let client: ThirdwebClient | undefined;\n\n  return {\n    id: \"inApp\",\n    subscribe: emitter.subscribe,\n    getChain() {\n      if (!chain) {\n        return undefined;\n      }\n\n      chain = getCachedChainIfExists(chain.id) || chain;\n      return chain;\n    },\n    getConfig: () => createOptions,\n    getAccount: () => account,\n    /**\n     * @description\n     * Gets the linked profiles for the current wallet.\n     * This method is only available for in-app or ecosystem wallets.\n     *\n     * @returns An array of accounts user profiles linked to the current wallet.\n     *\n     * @example\n     * ```ts\n     * import { inAppWallet } from \"thirdweb/wallets\";\n     *\n     * const wallet = inAppWallet();\n     * wallet.connect({ strategy: \"google\" });\n     *\n     * const profiles = wallet.getProfiles();\n     *\n     * console.log(profiles[0].type);\n     * console.log(profiles[0].details.email);\n     * ```\n     */\n    getProfiles: async () => {\n      if (!client) {\n        return [];\n      }\n\n      return getLinkedProfilesInternal({ client });\n    },\n    autoConnect: async (options) => {\n      const { autoConnectInAppWallet } = await import(\"./index.js\");\n\n      const connector = await getOrCreateInAppWalletConnector(\n        options.client,\n        connectorFactory,\n      );\n      const [connectedAccount, connectedChain] = await autoConnectInAppWallet(\n        options,\n        createOptions,\n        connector,\n      );\n      // set the states\n      client = options.client;\n      account = connectedAccount;\n      chain = connectedChain;\n      trackConnect({\n        client: options.client,\n        walletType: \"inApp\",\n        walletAddress: account.address,\n      });\n      // return only the account\n      return account;\n    },\n    connect: async (options) => {\n      const { connectInAppWallet } = await import(\"./index.js\");\n      const connector = await getOrCreateInAppWalletConnector(\n        options.client,\n        connectorFactory,\n      );\n\n      const [connectedAccount, connectedChain] = await connectInAppWallet(\n        options,\n        createOptions,\n        connector,\n      );\n      // set the states\n      client = options.client;\n      account = connectedAccount;\n      chain = connectedChain;\n      trackConnect({\n        client: options.client,\n        walletType: \"inApp\",\n        walletAddress: account.address,\n      });\n      // return only the account\n      return account;\n    },\n    disconnect: async () => {\n      // If no client is assigned, we should be fine just unsetting the states\n      if (client) {\n        const connector = await getOrCreateInAppWalletConnector(\n          client,\n          connectorFactory,\n        );\n        const result = await connector.logout();\n        if (!result.success) {\n          throw new Error(\"Failed to logout\");\n        }\n      }\n      account = undefined;\n      chain = undefined;\n      emitter.emit(\"disconnect\", undefined);\n    },\n    switchChain: async (newChain) => {\n      if (createOptions?.smartAccount && client && account) {\n        // if account abstraction is enabled, reconnect to smart account on the new chain\n        const { autoConnectInAppWallet } = await import(\"./index.js\");\n        const connector = await getOrCreateInAppWalletConnector(\n          client,\n          connectorFactory,\n        );\n        const [connectedAccount, connectedChain] = await autoConnectInAppWallet(\n          {\n            chain: newChain,\n            client,\n          },\n          createOptions,\n          connector,\n        );\n        account = connectedAccount;\n        chain = connectedChain;\n      } else {\n        // if not, simply set the new chain\n        chain = newChain;\n      }\n      emitter.emit(\"chainChanged\", newChain);\n    },\n    // This is not included on the global interface but is force-resolved in linkProfile\n    linkProfile: async (\n      options: SingleStepAuthArgsType | MultiStepAuthArgsType,\n    ): Promise<Profile[]> => {\n      if (!client) {\n        throw new Error(\n          \"No client found, please connect the wallet before linking a profile\",\n        );\n      }\n\n      const connector = await getOrCreateInAppWalletConnector(\n        client,\n        connectorFactory,\n      );\n\n      const { storedToken } = await connector.authenticate(options);\n      return await linkProfileWithToken({\n        client,\n        tokenToLink: storedToken.cookieString,\n      });\n    },\n  } as Wallet<\"inApp\">;\n}\n"],
  "mappings": "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",
  "names": []
}
