import { useState } from "react";
import { polygon } from "../../../../../../../chains/chain-definitions/polygon.js";
import { useActiveWalletChain } from "../../../../../../core/hooks/wallets/useActiveWalletChain.js";
import { useDebouncedValue } from "../../../../hooks/useDebouncedValue.js";
import { NATIVE_TOKEN } from "../../nativeToken.js";
import { currencies, usdCurrency, } from "../fiat/currencies.js";
// handle states for token and chain selection
export function useUISelectionStates(options) {
    const activeChain = useActiveWalletChain();
    const { payOptions, supportedDestinations } = options;
    // buy token amount ---------------------------------------------------------
    // NOTE - for transaction / direct payment modes, the token amount is set when the user tap continue
    const prefillBuy = payOptions?.prefillBuy;
    const initialTokenAmount = prefillBuy?.amount || "";
    const [tokenAmount, setTokenAmount] = useState(initialTokenAmount);
    const deferredTokenAmount = useDebouncedValue(tokenAmount, 300);
    // --------------------------------------------------------------------------
    // Destination chain and token selection -----------------------------------
    const [toChain, setToChain] = useState(
    // use prefill chain if available
    prefillBuy?.chain ||
        (payOptions.mode === "transaction" && payOptions.transaction?.chain) ||
        (payOptions.mode === "direct_payment" && payOptions.paymentInfo?.chain) ||
        // use active chain if its supported as destination
        supportedDestinations.find((x) => x.chain.id === activeChain?.id)
            ?.chain ||
        // default to polygon
        polygon);
    const [toToken, setToToken] = useState(prefillBuy?.token ||
        (payOptions.mode === "direct_payment" && payOptions.paymentInfo.token) ||
        NATIVE_TOKEN);
    // --------------------------------------------------------------------------
    // Source token and chain selection ---------------------------------------------------
    const [fromChain, setFromChain] = useState(
    // use prefill chain if available
    (payOptions.buyWithCrypto !== false &&
        payOptions.buyWithCrypto?.prefillSource?.chain) ||
        (payOptions.mode === "transaction" && payOptions.transaction?.chain) ||
        (payOptions.mode === "direct_payment" && payOptions.paymentInfo?.chain) ||
        // default to polygon
        polygon);
    const [fromToken, setFromToken] = useState(
    // use prefill token if available
    (payOptions.buyWithCrypto !== false &&
        payOptions.buyWithCrypto?.prefillSource?.token) ||
        (payOptions.mode === "direct_payment" && payOptions.paymentInfo.token) ||
        // default to native token
        NATIVE_TOKEN);
    // --------------------------------------------------------------------------
    const devSpecifiedDefaultCurrency = payOptions.buyWithFiat !== false
        ? payOptions.buyWithFiat?.prefillSource?.currency
        : undefined;
    const defaultSelectedCurrencyShorthand = devSpecifiedDefaultCurrency || getDefaultCurrencyBasedOnLocation();
    const [selectedCurrency, setSelectedCurrency] = useState(currencies.find((x) => x.shorthand === defaultSelectedCurrencyShorthand) ||
        usdCurrency);
    return {
        tokenAmount,
        setTokenAmount,
        toChain,
        setToChain,
        deferredTokenAmount,
        fromChain,
        setFromChain,
        toToken,
        setToToken,
        fromToken,
        setFromToken,
        selectedCurrency,
        setSelectedCurrency,
    };
}
function getDefaultCurrencyBasedOnLocation() {
    // if Intl is not supported - browser throws
    try {
        const timeZone = Intl.DateTimeFormat()
            .resolvedOptions()
            .timeZone.toLowerCase();
        // Europe/London -> GBP
        if (timeZone.includes("london")) {
            return "GBP";
        }
        // Europe/* -> EUR
        if (timeZone.includes("europe")) {
            return "EUR";
        }
        // Japan
        if (timeZone.includes("japan")) {
            return "JPY";
        }
        // canada
        if (timeZone.includes("canada")) {
            return "CAD";
        }
        return "USD";
    }
    catch {
        return "USD";
    }
}
//# sourceMappingURL=useUISelectionStates.js.map