"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Connector = void 0;
var _react = _interopRequireDefault(require("react"));
var _ = require("./..");
var _antd = require("antd");
var _useProvider = _interopRequireDefault(require("../hooks/useProvider"));
var _jsxRuntime = require("react/jsx-runtime");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const Connector = props => {
  const {
    children,
    modalProps,
    onConnect,
    onConnected,
    onDisconnect,
    onDisconnected,
    onChainSwitched,
    onConnectError
  } = props;
  const {
    availableWallets,
    connect,
    disconnect,
    account,
    availableChains,
    chain,
    switchChain,
    balance,
    addressPrefix
  } = (0, _useProvider.default)(props);
  const [open, setOpen] = _react.default.useState(false);
  const [connecting, setConnecting] = _react.default.useState(false);
  const [defaultSelectedWallet, setDefaultSelectedWallet] = _react.default.useState();
  const actionRef = _react.default.useRef();
  const [messageApi, contextHolder] = _antd.message.useMessage();
  const connectWallet = async (wallet, options) => {
    onConnect?.();
    try {
      setConnecting(true);
      const connectedAccount = await connect?.(wallet, options);
      onConnected?.(connectedAccount ? connectedAccount : undefined);
      setOpen(false);
    } catch (e) {
      if (typeof onConnectError === 'function') {
        onConnectError(e);
      } else {
        messageApi.error(e.message);
        console.error(e);
      }
    } finally {
      setConnecting(false);
    }
  };
  if (! /*#__PURE__*/_react.default.isValidElement(children)) {
    console.error('"children" property of the "Connector" is must be a React element');
    return null;
  }
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
    children: [contextHolder, /*#__PURE__*/_react.default.cloneElement(children, {
      account,
      onConnectClick: async wallet => {
        if (!wallet) {
          setOpen(true);
          return;
        }
        if (await wallet?.hasExtensionInstalled?.()) {
          // call extension directly
          connectWallet(wallet, {
            connectType: 'extension'
          });
          return;
        }
        // show qr code
        if (actionRef.current?.selectWallet) {
          // ConnectModal already mounted, call select
          actionRef.current.selectWallet(wallet);
        } else {
          // ConnectModal not mounted, set defaultSelectWallet
          connectWallet(wallet, {
            connectType: 'qrCode'
          });
          setDefaultSelectedWallet(wallet);
        }
        setOpen(true);
      },
      onDisconnectClick: () => {
        setConnecting(true);
        onDisconnect?.();
        disconnect?.().then(() => {
          onDisconnected?.();
          setConnecting(false);
        });
      },
      balance,
      availableChains,
      availableWallets,
      chain,
      addressPrefix,
      onSwitchChain: async c => {
        await switchChain?.(c);
        onChainSwitched?.(c);
      },
      loading: connecting,
      ...children.props
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_.ConnectModal, {
      connecting: connecting,
      open: open,
      actionRef: actionRef,
      defaultSelectedWallet: defaultSelectedWallet,
      walletList: availableWallets,
      ...modalProps,
      onWalletSelected: async (wallet, options) => {
        await connectWallet(wallet, options);
      },
      onCancel: e => {
        modalProps?.onCancel?.(e);
        setOpen(false);
        setConnecting(false);
        modalProps?.onCancel?.(e);
      }
    })]
  });
};
exports.Connector = Connector;