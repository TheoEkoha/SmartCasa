"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConnectButton = void 0;
var _react = _interopRequireWildcard(require("react"));
var _icons = require("@ant-design/icons");
var _antd = require("antd");
var _classnames = _interopRequireDefault(require("classnames"));
var _address = require("../address");
var _cryptoPrice = require("../crypto-price");
var _hooks = require("../hooks");
var _useIntl = _interopRequireDefault(require("../hooks/useIntl"));
var _utils = require("../utils");
var _chainSelect = require("./chain-select");
var _connectButtonInner = require("./connect-button-inner");
var _profileModal = require("./profile-modal");
var _style = require("./style");
var _tooltip = require("./tooltip");
var _jsxRuntime = require("react/jsx-runtime");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const ConnectButton = props => {
  const {
    onConnectClick,
    onDisconnectClick,
    availableChains,
    availableWallets,
    onSwitchChain,
    tooltip,
    chain,
    account,
    avatar,
    profileModal = true,
    onMenuItemClick,
    actionsMenu = false,
    loading,
    onClick,
    balance,
    className,
    locale,
    quickConnect,
    addressPrefix: addressPrefixProp,
    ...restProps
  } = props;
  const intl = (0, _useIntl.default)('ConnectButton', locale);
  const {
    getPrefixCls
  } = (0, _react.useContext)(_antd.ConfigProvider.ConfigContext);
  const {
    addressPrefix: addressPrefixContext
  } = (0, _hooks.useProvider)();
  const prefixCls = getPrefixCls('web3-connect-button');
  const [profileOpen, setProfileOpen] = (0, _react.useState)(false);
  const {
    wrapSSR,
    hashId
  } = (0, _style.useStyle)(prefixCls);
  const [messageApi, contextHolder] = _antd.message.useMessage();
  const [showMenu, setShowMenu] = (0, _react.useState)(false);
  let buttonText = intl.getMessage(intl.messages.connect);
  if (account) {
    buttonText = account?.name && !balance ? account?.name : /*#__PURE__*/(0, _jsxRuntime.jsx)(_address.Address, {
      tooltip: false,
      ellipsis: true,
      address: account.address,
      addressPrefix: addressPrefixProp,
      children: balance ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_cryptoPrice.CryptoPrice, {
        icon: true,
        ...balance
      }) : undefined
    });
  }
  const buttonProps = {
    style: props.style,
    size: props.size,
    type: props.type,
    ghost: props.ghost,
    loading,
    className: (0, _classnames.default)(className, prefixCls, hashId),
    onClick: e => {
      setShowMenu(false);
      if (account && !profileOpen && profileModal) {
        setProfileOpen(true);
      }
      onClick?.(e);
    },
    ...restProps
  };
  const chainProps = {
    hashId,
    onSwitchChain,
    currentChain: chain,
    chains: availableChains,
    buttonProps: {
      size: props.size,
      type: props.type
    }
  };
  const chainIcon = account?.avatar ?? chain?.icon;
  const profileModalProps = {
    intl,
    open: profileOpen,
    __hashId__: hashId,
    onDisconnect: () => {
      setProfileOpen(false);
      onDisconnectClick?.();
    },
    onClose: () => {
      setProfileOpen(false);
    },
    address: account?.address,
    name: account?.name,
    avatar: {
      className: chainIcon ? `${prefixCls}-chain-icon` : `${prefixCls}-chain-icon ${prefixCls}-default-icon`,
      src: chainIcon,
      icon: !chainIcon && /*#__PURE__*/(0, _jsxRuntime.jsx)(_icons.UserOutlined, {}),
      ...avatar
    },
    balance,
    modalProps: typeof profileModal === 'object' ? profileModal : undefined,
    addressPrefix: addressPrefixProp,
    size: props.size
  };
  const chainSelect = availableChains && availableChains.length > 1 ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_chainSelect.ChainSelect, {
    ...chainProps
  }) : null;
  const buttonInnerText = /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: `${prefixCls}-content`,
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: `${prefixCls}-content-inner`,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: `${prefixCls}-text`,
        children: buttonText
      }), (account?.avatar || avatar) && /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_antd.Divider, {
          type: "vertical"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: `${prefixCls}-avatar`,
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_antd.Avatar, {
            src: account?.avatar ?? avatar?.src,
            ...avatar
          })
        })]
      })]
    })
  });
  const buttonContent = /*#__PURE__*/(0, _jsxRuntime.jsx)(_connectButtonInner.ConnectButtonInner, {
    intl: intl,
    ...buttonProps,
    preContent: chainSelect,
    showQuickConnect: quickConnect && !account,
    availableWallets: availableWallets,
    onConnectClick: wallet => {
      if (!account) {
        onConnectClick?.(wallet);
      }
    },
    __hashId__: hashId,
    children: buttonInnerText
  });
  const defaultMenuItems = (0, _react.useMemo)(() => [{
    label: intl.getMessage(intl.messages.copyAddress),
    key: 'copyAddress',
    onClick: () => {
      setProfileOpen(false);
      if (account?.address) {
        (0, _utils.writeCopyText)(account?.address).then(() => {
          messageApi.success(intl.messages.copied);
        });
      }
    },
    icon: /*#__PURE__*/(0, _jsxRuntime.jsx)(_icons.CopyOutlined, {})
  }, {
    label: intl.getMessage(intl.messages.disconnect),
    key: 'disconnect',
    onClick: () => {
      setProfileOpen(false);
      onDisconnectClick?.();
    },
    icon: /*#__PURE__*/(0, _jsxRuntime.jsx)(_icons.LoginOutlined, {})
  }], [account?.address, messageApi, onDisconnectClick]);
  const mergedMenuItems = (0, _react.useMemo)(() => {
    if (!actionsMenu) {
      return [];
    }
    if (typeof actionsMenu === 'boolean') {
      return account ? defaultMenuItems : [];
    }
    if (actionsMenu.items) {
      return actionsMenu.items;
    }
    const combinedItems = account ? actionsMenu.extraItems ? [...actionsMenu.extraItems, ...defaultMenuItems] : defaultMenuItems : actionsMenu.extraItems || [];
    return combinedItems;
  }, [actionsMenu, defaultMenuItems, account]);
  const content = mergedMenuItems.length > 0 ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_antd.Dropdown, {
    open: showMenu,
    onOpenChange: setShowMenu,
    menu: {
      items: mergedMenuItems,
      onClick: onMenuItemClick
    },
    children: buttonContent
  }) : buttonContent;
  const mergedTooltipCopyable = typeof tooltip === 'object' ? tooltip.copyable !== false : !!tooltip;
  let tooltipTitle = tooltip && account?.address ? (0, _utils.fillWithPrefix)(account?.address, addressPrefixProp, addressPrefixContext) : '';
  if (typeof tooltip === 'object' && typeof tooltip.title === 'string') {
    tooltipTitle = tooltip.title;
  }
  const main = /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
    children: [contextHolder, tooltipTitle ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_tooltip.ConnectButtonTooltip, {
      intl: intl,
      copyable: mergedTooltipCopyable,
      title: tooltipTitle,
      prefixCls: prefixCls,
      __hashId__: hashId,
      ...(typeof tooltip === 'object' ? tooltip : {}),
      children: content
    }) : content, /*#__PURE__*/(0, _jsxRuntime.jsx)(_profileModal.ProfileModal, {
      ...profileModalProps
    })]
  });
  return wrapSSR(main);
};
exports.ConnectButton = ConnectButton;
ConnectButton.displayName = 'ConnectButton';